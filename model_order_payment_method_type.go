/*
Партнерский API Маркета

API Яндекс Маркета помогает продавцам автоматизировать и упростить работу с маркетплейсом.  В числе возможностей интеграции:  * управление каталогом товаров и витриной,  * обработка заказов,  * изменение настроек магазина,  * получение отчетов.

API version: LATEST
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"encoding/json"
	"fmt"
)

// OrderPaymentMethodType Способ оплаты заказа:  * Значения, если выбрана оплата при оформлении заказа (`\"paymentType\": \"PREPAID\"`):    * `YANDEX` — банковской картой.    * `APPLE_PAY` — Apple Pay.    * `GOOGLE_PAY` — Google Pay.    * `CREDIT` — в кредит.    * `TINKOFF_CREDIT` — в кредит в Тинькофф Банке.    * `TINKOFF_INSTALLMENTS` — рассрочка в Тинькофф Банке.    * `EXTERNAL_CERTIFICATE` — подарочным сертификатом (например, из приложения «Сбербанк Онлайн»).    * `SBP` — через систему быстрых платежей.    * `B2B_ACCOUNT_PREPAYMENT` — заказ оплачивает организация.   * Значения, если выбрана оплата при получении заказа (`\"paymentType\": \"POSTPAID\"`):    * `CARD_ON_DELIVERY` — банковской картой.    * `BOUND_CARD_ON_DELIVERY` — привязанной картой при получении.    * `BNPL_BANK_ON_DELIVERY` — супер Сплитом.    * `BNPL_ON_DELIVERY` — Сплитом.    * `CASH_ON_DELIVERY` — наличными.    * `B2B_ACCOUNT_POSTPAYMENT` — заказ оплачивает организация после доставки.  * `UNKNOWN` — неизвестный тип.  Значение по умолчанию: `CASH_ON_DELIVERY`.
type OrderPaymentMethodType string

// List of OrderPaymentMethodType
const (
	CASH_ON_DELIVERY         OrderPaymentMethodType = "CASH_ON_DELIVERY"
	CARD_ON_DELIVERY         OrderPaymentMethodType = "CARD_ON_DELIVERY"
	BOUND_CARD_ON_DELIVERY   OrderPaymentMethodType = "BOUND_CARD_ON_DELIVERY"
	BNPL_BANK_ON_DELIVERY    OrderPaymentMethodType = "BNPL_BANK_ON_DELIVERY"
	BNPL_ON_DELIVERY         OrderPaymentMethodType = "BNPL_ON_DELIVERY"
	YANDEX                   OrderPaymentMethodType = "YANDEX"
	APPLE_PAY                OrderPaymentMethodType = "APPLE_PAY"
	EXTERNAL_CERTIFICATE     OrderPaymentMethodType = "EXTERNAL_CERTIFICATE"
	CREDIT                   OrderPaymentMethodType = "CREDIT"
	GOOGLE_PAY               OrderPaymentMethodType = "GOOGLE_PAY"
	TINKOFF_CREDIT           OrderPaymentMethodType = "TINKOFF_CREDIT"
	SBP                      OrderPaymentMethodType = "SBP"
	TINKOFF_INSTALLMENTS     OrderPaymentMethodType = "TINKOFF_INSTALLMENTS"
	B2_B_ACCOUNT_PREPAYMENT  OrderPaymentMethodType = "B2B_ACCOUNT_PREPAYMENT"
	B2_B_ACCOUNT_POSTPAYMENT OrderPaymentMethodType = "B2B_ACCOUNT_POSTPAYMENT"
	UNKNOWN                  OrderPaymentMethodType = "UNKNOWN"
)

// All allowed values of OrderPaymentMethodType enum
var AllowedOrderPaymentMethodTypeEnumValues = []OrderPaymentMethodType{
	"CASH_ON_DELIVERY",
	"CARD_ON_DELIVERY",
	"BOUND_CARD_ON_DELIVERY",
	"BNPL_BANK_ON_DELIVERY",
	"BNPL_ON_DELIVERY",
	"YANDEX",
	"APPLE_PAY",
	"EXTERNAL_CERTIFICATE",
	"CREDIT",
	"GOOGLE_PAY",
	"TINKOFF_CREDIT",
	"SBP",
	"TINKOFF_INSTALLMENTS",
	"B2B_ACCOUNT_PREPAYMENT",
	"B2B_ACCOUNT_POSTPAYMENT",
	"UNKNOWN",
}

func (v *OrderPaymentMethodType) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := OrderPaymentMethodType(value)
	for _, existing := range AllowedOrderPaymentMethodTypeEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid OrderPaymentMethodType", value)
}

// NewOrderPaymentMethodTypeFromValue returns a pointer to a valid OrderPaymentMethodType
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewOrderPaymentMethodTypeFromValue(v string) (*OrderPaymentMethodType, error) {
	ev := OrderPaymentMethodType(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for OrderPaymentMethodType: valid values are %v", v, AllowedOrderPaymentMethodTypeEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v OrderPaymentMethodType) IsValid() bool {
	for _, existing := range AllowedOrderPaymentMethodTypeEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to OrderPaymentMethodType value
func (v OrderPaymentMethodType) Ptr() *OrderPaymentMethodType {
	return &v
}

type NullableOrderPaymentMethodType struct {
	value *OrderPaymentMethodType
	isSet bool
}

func (v NullableOrderPaymentMethodType) Get() *OrderPaymentMethodType {
	return v.value
}

func (v *NullableOrderPaymentMethodType) Set(val *OrderPaymentMethodType) {
	v.value = val
	v.isSet = true
}

func (v NullableOrderPaymentMethodType) IsSet() bool {
	return v.isSet
}

func (v *NullableOrderPaymentMethodType) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableOrderPaymentMethodType(val *OrderPaymentMethodType) *NullableOrderPaymentMethodType {
	return &NullableOrderPaymentMethodType{value: val, isSet: true}
}

func (v NullableOrderPaymentMethodType) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableOrderPaymentMethodType) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}
